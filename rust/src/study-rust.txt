 Владение//
Стек: последний вошёл - первый вышел
Куча: Место выделяется самостоятельно и всё медленно и разбросано
У каждого значения есть только один владелец
Когда мы выходим с какой-то области видимости, то её переменные, функции и прочее очищается
Копирование - передача значения, хранящийся в стеке
Перемещение - передача значения, хранящийся в куче, и самоудаление
String.clone() - клонирование
 _________Стек________
/      |      |    \  кортежи со всеми этими типами
дробные |      |     \_
    целые  без знака  булевые
Когда кучевые занчения указывают как аргумент функции они перемещаются
Возвращаемое значение функции _перемещается_ в указанную переменную
   Ссылки//
String = значение &String = ссылка
Ссылки - крутые, они передают значение без потерь производительности и памяти
Но ссылки по умолчанию не изменяемы, &mut String - будет изменяться
String.push_str("...") - конкатенация
Нельзя использовать две изменяемых ссылки на одну переменную
Можно дофегища раз использовать обычные ссылки!
Висящая ссылка - ссылка на ничего
   Срезы//
Ссылочный тип данных &String[begin..end]
Begin по умолчанию равен 0
End по умолчанию равен самому последнему символу
   Структуры//
Следует создавать до функции мейн
struct _ {
	ключ: тип значения,
	ключ: тип значения,
};
Это как классики
Отклонение: "...".to_string() - тоже можно
#[derive(Debug)] - это аннотация (хз), нужно для того, чтобы печатать структуру
объект.значение - так обращаются к значению
можно присваивать другие значения если сделать весь объект мутабельным
если ключ совпадает с одной из переменной то можно написать имя той переменной и всё
если ключи совпадают с переменными и объект уже когда-то создавался, то можно написать ..first_object и переменные сами подставятся под ключи
Отклонение: число.sqrt() - корень квадратный
impl имя структуры {
	fn имя метода(&self){
		бла-бла-бла
	} без ;
	другие методы...
} - создание метода для структуры (метод Rust = метод JS = метод Python)
Struct::func(...) - несвязанная функция, то, что не требует ссылки на структуру в аргументах
можно создать несколько блоков impl
   Перечесления//
Перечисление создаётся за пределами главной функции
И с помощь спец. слова enum {
	тра-та-та-та-та-та
}
А присваивается = Enum::Element
Чтобы его обработать нужно использовать match
match Enum::Element {
	Enum::Variant_one => ... ,
	Enum::Variant_two => ...
}; Уот и всо
enum Name {
	el(par),
	el,
	el
} - Здесь можно первому элементу добавить какое-то значение, а потом тоже обработать
match name {
	Name::el(YouCanCallParameterHowWant) => ... ,
	Name::el => ... ,
	Name::el => ... ,
	_ => ... // _ = else 
};
К перечислениям также можно приделывать имплы
    Векторы//
Это суперпупер вещь  - массив с изменяемой длиной! УРААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААААА!
Создание - vec![ылементы]
Можно создать пустой, только с указанием типа данных - let имя : Vec<тип данных> = Vec::new();
vec.push(значение) - ... жабаскрипт
vec.remove(индекс) - ... всё интуитивно
vec[индекс] - получение ылемента
vec.get(индекс) - другое получение ылемента
Этеншн! Эта фигня ^ это что-то объектое, печатать через {:?}
Но при этом при неправильном индексе она не вызывает ошибку
	Строки//
String::new(); - создает пустую строку
String::from($str); - создаёт строку из нечто в кавычках
$str.to_string(); - точно также
$str.push_str(string: $str); - добавление второй строки в конец первой
$str.push(ch: $char) - тоже самое только быстрее и для символов
Конкатенация осуществляется через плюс, при этом первый операнд обязательно должен перемещаться, а второй указываться в каестве ссылки
format!("{}", $str) - макрокоманда для конкатенации, здесь не надо указывать ссылки и она ни чего не перемещает
$str.len(); - возвращает длину строки
Индексированние строк не поддерживается, обращаться нужно относительно байтов, у каждого языка (не прогарммирования) есть свои приколы с этим
Для того чтобы перебрать строку в цикле нужно:
for i in $str.chars()/.bytes(){
	...
}; - первое посимвольно, второе побайтово
	ХешКарты//
Это типо объекты в жабаскритпе, 
use std::collections::HashMap - импорт хешкарт
HashMap::new() - создание пустого хашмапки
Для того чтобы чё-то вставить надо использовать метод insert с параметрами k и v - HashMap::new().insert($str, $*);
Обращение к значения такое же как и в питоне, но если тип данных ключа это ссылка, то и в в квадратных скобках нужно указывать точно такую же ссылку
Иначе же можно воспользоваться get, который нужно обрабатывать через match
хешмапик можно перебирать чрез for
Существует метод entry() который проверяет наличие пары
or_insert() меняет значене ключа той пары либо нихрена не делает 
Отклонение: $str.split_whitespace() - разделяет строку по пробелам
Отклонение: $str.to_lowercase() и $str.to_uppercase()
	Обработка ошибок//
panic!($str) - суеты навести охота
тип данных Result<some, some> имеет в себе два веща - возвращаемый результат есили усипех, иначе возврат второго аргумента - ошибки, а обработочка обязательно с через match
Если вдруг нам приспичило обработать определённую ошибку, то в варианте Err того самого match фигачим ещё один match где уже сравниваем e.kind() со значениями перечисления ErrorKind
дефолт для ошибок other:ErrorKind
